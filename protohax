local repo = "https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/"

local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()
local Options = Library.Options
local Toggles = Library.Toggles

Library.ShowToggleFrameInKeybinds = true
Library.ShowCustomCursor = true
Library.NotifySide = "Left"

local Window = Library:CreateWindow({
	Title = "Protohax",
	Center = true,
	AutoShow = true,
	Resizable = true,
	ShowCustomCursor = true,
	NotifySide = "Left",
	TabPadding = 8,
	MenuFadeTime = 0.2,
})

local Tabs = {
	Main = Window:AddTab("Main"),
	Exploits = Window:AddTab("Exploits"),
	ESP = Window:AddTab("ESP"),
	Visual = Window:AddTab("Visual"),
	["UI Settings"] = Window:AddTab("UI Settings"),
}

local Main = Tabs.Main:AddLeftGroupbox("Main")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

do
	local LocalPlayer = Players.LocalPlayer
	local roomsFolder = Workspace:WaitForChild("CurrentRooms")
	local CHECK_DISTANCE = 12.5
	local MAX_CHECK_PER_STEP = 10

	local storedPrompts = {}
	local heartbeatConn, descendantConn
	local throttle = 0

	local staticIgnored = {
		HidePrompt = true,
		ClimbPrompt = true,
		PushPrompt = true,
		InteractPrompt = true,
		PropPrompt = true,
		StarRiftPrompt = true,
		RiftPrompt = true
	}

	local ignoreList = {}
	local namedIgnoreFolders = {
		["Jeff's Items"] = function()
			for _, room in pairs(roomsFolder:GetChildren()) do
				local shop = room:FindFirstChild("JeffShop_Hotel")
				if shop then
					for i = 1, 4 do
						local item = shop:FindFirstChild("PurchasableItem"..i)
						if item then
							ignoreList[item] = true
						end
					end
				end
			end
		end
	}

	local supportsFire = pcall(function()
		fireproximityprompt(Instance.new("ProximityPrompt"))
	end)

	local function doPrompt(prompt)
		if not (prompt and prompt.Enabled) then return end
		if supportsFire then
			fireproximityprompt(prompt)
		else
			prompt:InputHoldBegin()
			task.wait(prompt.HoldDuration or 0)
			prompt:InputHoldEnd()
		end
	end

	local function getPartFrom(parent)
		if parent:IsA("BasePart") then return parent end
		if parent:IsA("Model") then
			for _, obj in ipairs(parent:GetChildren()) do
				if obj:IsA("BasePart") then return obj end
			end
		end
		return nil
	end

	local function shouldIgnore(prompt)
		if staticIgnored[prompt.Name] then return true end
		if ignoreList[prompt.Parent] then return true end
		return false
	end

	local function trackPrompt(prompt)
		if not (prompt.Enabled and prompt:IsDescendantOf(roomsFolder)) then return end
		if shouldIgnore(prompt) then return end
		local part = getPartFrom(prompt.Parent)
		if part then
			storedPrompts[prompt] = part
		end
	end

	local function cleanStoredPrompts()
		for prompt, part in pairs(storedPrompts) do
			if not (prompt:IsDescendantOf(roomsFolder) and part and part:IsDescendantOf(roomsFolder) and prompt.Enabled) then
				storedPrompts[prompt] = nil
			end
		end
	end

Main:AddToggle("AutoInteract", {
    Text = "Auto Interact",
    Default = false,
    Callback = function(Value)
        if heartbeatConn then heartbeatConn:Disconnect() end
        if descendantConn then descendantConn:Disconnect() end
        heartbeatConn, descendantConn = nil, nil
        table.clear(storedPrompts)
        throttle = 0

        if not Value then return end

        for _, inst in ipairs(roomsFolder:GetDescendants()) do
            if inst:IsA("ProximityPrompt") then
                trackPrompt(inst)
            end
        end

        descendantConn = roomsFolder.DescendantAdded:Connect(function(inst)
            if inst:IsA("ProximityPrompt") then
                trackPrompt(inst)
            end
        end)

        heartbeatConn = RunService.Heartbeat:Connect(function(dt)
            throttle += dt
            if throttle < 0.05 then return end
            throttle = 0

            local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            local pos = hrp.Position

            cleanStoredPrompts()

            local checked = 0
            for prompt, part in pairs(storedPrompts) do
                if checked >= MAX_CHECK_PER_STEP then break end
                if prompt:IsDescendantOf(roomsFolder)
                    and part and part:IsDescendantOf(roomsFolder)
                    and prompt.Enabled
                    and (pos - part.Position).Magnitude <= CHECK_DISTANCE then
                    doPrompt(prompt)
                    checked += 1
                end
            end
        end)
    end
}):AddKeyPicker("AutoInteractKeybind", {
    Default = "M",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Auto Interact",
    NoUI = false
})
end

Main:AddDropdown(" IgnoreList", {
    Values = {"Jeff's Items"},
    Default = {"Jeff's Items"},
    Multi = true,
    Text = "Ignore List",
    Callback = function()
        table.clear(ignoreList)
        for _, name in next, Options.IgnoreList.Value do
            if namedIgnoreFolders[name] then
                namedIgnoreFolders[name]()
            end
        end
    end
})

local connection

Main:AddToggle("InstantInteract", {
    Text = "Instant Interact",
    Default = false,
    Callback = function(Value)
    if Value then
        connection = game:GetService("ProximityPromptService").PromptButtonHoldBegan:Connect(function(prompt)
            fireproximityprompt(prompt)
        end)
    else
        if connection then
            connection:Disconnect()
            connection = nil
        end
    end
    end
})

local promptClipEnabled = false
local originalLOS = {}

local function ClipPrompt(prompt)
    if not (prompt and prompt:IsA("ProximityPrompt")) then return end
    if originalLOS[prompt] == nil then
        originalLOS[prompt] = prompt.RequiresLineOfSight
    end
    prompt.RequiresLineOfSight = false
end

local function RestorePrompt(prompt)
    if prompt and originalLOS[prompt] ~= nil then
        prompt.RequiresLineOfSight = originalLOS[prompt]
        originalLOS[prompt] = nil
    end
end

local function UpdateAllPrompts()
    for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
        for _, prompt in ipairs(room:GetDescendants()) do
            if prompt:IsA("ProximityPrompt") then
                ClipPrompt(prompt)
            end
        end
    end
end

local function RestoreAllPrompts()
    for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
        for _, prompt in ipairs(room:GetDescendants()) do
            if prompt:IsA("ProximityPrompt") then
                RestorePrompt(prompt)
            end
        end
    end
end

Main:AddToggle("PromptClip", {
    Text = "Prompt Clip",
    Default = false,
    Callback = function(Value)
        promptClipEnabled = Value

        if promptClipEnabled then
            UpdateAllPrompts()
            workspace.CurrentRooms.DescendantAdded:Connect(function(descendant)
                if promptClipEnabled and descendant:IsA("ProximityPrompt") then
                    ClipPrompt(descendant)
                end
            end)
        else
            RestoreAllPrompts()
        end
    end
})

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

local PromptReachEnabled = false
local PromptReachDistance = 8
local originalDistances = {}

local function applyPrompt(prompt)
    if not prompt:IsA("ProximityPrompt") then return end
    if not originalDistances[prompt] then
        originalDistances[prompt] = prompt.MaxActivationDistance
    end
    if PromptReachEnabled then
        prompt.MaxActivationDistance = PromptReachDistance
    else
        prompt.MaxActivationDistance = originalDistances[prompt]
    end
end

for _, prompt in ipairs(Workspace:GetDescendants()) do
    applyPrompt(prompt)
end

Workspace.DescendantAdded:Connect(function(desc)
    if desc:IsA("ProximityPrompt") then
        applyPrompt(desc)
    end
end)

Main:AddToggle("PromptReach", {
    Text = "Prompt Reach",
    Default = false,
    Callback = function(Value)
        PromptReachEnabled = Value
        for _, prompt in ipairs(Workspace:GetDescendants()) do
            applyPrompt(prompt)
        end
    end
})

Main:AddSlider("PromptReachSlider", {
    Text = "Prompt Reach Distance",
    Min = 8,
    Max = 14.5,
    Default = 8,
    Rounding = 1,
    Callback = function(Value)
        PromptReachDistance = Value
        if PromptReachEnabled then
            for _, prompt in ipairs(Workspace:GetDescendants()) do
                if prompt:IsA("ProximityPrompt") then
                    prompt.MaxActivationDistance = PromptReachDistance
                end
            end
        end
    end
})

local Movement = Tabs.Main:AddLeftGroupbox("Movement")

Movement:AddToggle("EnableJump", {
    Text = "Enable Jump",
    Default = false,
    Callback = function(Value)
    local Character = game.Players.LocalPlayer.Character
    
    Character:SetAttribute("CanJump", Value)
    end
})

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local v3zero = Vector3.new(0, 0, 0)
local v3inf = Vector3.new(9e9, 9e9, 9e9)

local speaker = game.Players.LocalPlayer
local camera = workspace.CurrentCamera
local controlModule = require(speaker.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))

local velocityHandlerName = "VelocityHandler"
local gyroHandlerName = "GyroHandler"

local flying = false
local renderSteppedConnection
local FlightSpeed = 16

local function setupFlyingParts(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart")
    for _, child in pairs(rootPart:GetChildren()) do
        if child.Name == velocityHandlerName or child.Name == gyroHandlerName then
            child:Destroy()
        end
    end

    local bv = Instance.new("BodyVelocity")
    bv.Name = velocityHandlerName
    bv.Parent = rootPart
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = gyroHandlerName
    bg.Parent = rootPart
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50
end

local function disableFlying(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    for _, child in pairs(rootPart:GetChildren()) do
        if child.Name == velocityHandlerName or child.Name == gyroHandlerName then
            child:Destroy()
        end
    end
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
    end
end

local function onRenderStep()
    local character = speaker.Character
    if not character then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if not rootPart or not humanoid then return end

    local velocityHandler = rootPart:FindFirstChild(velocityHandlerName)
    local gyroHandler = rootPart:FindFirstChild(gyroHandlerName)
    if not velocityHandler or not gyroHandler then return end

    velocityHandler.MaxForce = v3inf
    gyroHandler.MaxTorque = v3inf

    humanoid.PlatformStand = true

    gyroHandler.CFrame = camera.CFrame
    velocityHandler.Velocity = v3zero

    local moveVector = controlModule:GetMoveVector()

    if moveVector.X ~= 0 then
        local rightVector = camera.CFrame.RightVector
        velocityHandler.Velocity = velocityHandler.Velocity + rightVector * (moveVector.X * FlightSpeed)
    end

    if moveVector.Z ~= 0 then
        local lookVector = camera.CFrame.LookVector
        velocityHandler.Velocity = velocityHandler.Velocity - lookVector * (moveVector.Z * FlightSpeed)
    end
end

Movement:AddToggle("FlightToggle", {
    Text = "Flight",
    Default = false,
    Callback = function(state)
        flying = state
        local character = speaker.Character or speaker.CharacterAdded:Wait()
        if flying then
            setupFlyingParts(character)
            renderSteppedConnection = RunService.RenderStepped:Connect(onRenderStep)
        else
            if renderSteppedConnection then
                renderSteppedConnection:Disconnect()
                renderSteppedConnection = nil
            end
            disableFlying(character)
        end
    end
}):AddKeyPicker('FlightKeybind', {
    Default = 'F',
    SyncToggleState = true,
    Mode = Library.IsMobile and 'Toggle' or 'Hold',
    Text = 'Flight',
    NoUI = false,
    Callback = function(Value) end,
    ChangedCallback = function(New) end
})

Movement:AddSlider("FlightSpeedSlider", {
    Text = "Flight Speed",
    Default = 15,
    Min = 15,
    Max = 21,
    Rounding = 0,
    Callback = function(Value)
        FlightSpeed = Value
    end
})

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local SpeedConnection
local FOVConnection

Movement:AddToggle("SpeedToggle", {
    Text = "Enable Speed",
    Default = false,
    Callback = function(Value)
        if Value then
            SpeedConnection = RunService.Heartbeat:Connect(function()
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    LocalPlayer.Character.Humanoid.WalkSpeed = _G.SpeedValue or 16
                end
            end)
        else
            if SpeedConnection then SpeedConnection:Disconnect() end
            SpeedConnection = nil
            LocalPlayer.Character.Humanoid.WalkSpeed = 15
        end
    end
})

Movement:AddToggle("FOVToggle", {
    Text = "Enable Field Of View",
    Default = false,
    Callback = function(Value)
        if Value then
            FOVConnection = RunService.RenderStepped:Connect(function()
                workspace.CurrentCamera.FieldOfView = _G.FOVValue or 70
            end)
        else
            if FOVConnection then
                FOVConnection:Disconnect()
                FOVConnection = nil
            end
            workspace.CurrentCamera.FieldOfView = 70
        end
    end
})

Movement:AddSlider("SpeedSlider", {
    Text = "Speed",
    Default = 15,
    Min = 15,
    Max = 21,
    Rounding = 0,
    Callback = function(Value)
        _G.SpeedValue = Value
    end
})

Movement:AddSlider("FOVSlider", {
    Text = "Field Of View",
    Default = 70,
    Min = 70,
    Max = 120,
    Rounding = 0,
    Callback = function(Value)
        _G.FOVValue = Value
    end
})

local Notification = Tabs.Main:AddRightGroupbox("Notification")

local entities = {
    RushMoving = "Rush has spawned!",
    AmbushMoving = "Ambush has spawned!",
    Eyes = "Eyes has spawned!",
    A60 = "A60 has spawned!",
    A120 = "A120 has spawned!",
    BackdoorRush = "Blitz has spawned!",
    BackdoorLookman = "Lookman has spawned!",
    Screech = "Screech has spawned!",
    GiggleCeiling = "Giggle has spawned!",
    GlitchRush = "Glitched Rush has spawned!",
    GlitchAmbush = "Glitched Ambush has spawned!",
    GlitchedScreech = "Glitched Screech has spawned!",
    SeekMoving = "Seek has spawned!",
    SeekMovingNewClone = "Seek has spawned!",
    JeffTheKiller = "Jeff The Killer has spawned!"
}

local whitelist = {}
local entityNotifierEnabled = false
local chatNotifierEnabled = false

local entityNames = {}
for name in pairs(entities) do
    table.insert(entityNames, name)
end

Notification:AddDropdown("EntitiesNotificationWhitelist", {
    Text = "Entity Notification Whitelist",
    Values = entityNames,
    Default = {entityNames[1]},
    Multi = true,
    Callback = function(selected)
        whitelist = {}
        if #selected > 0 then
            for _, name in ipairs(selected) do
                if type(name) == "string" then
                    whitelist[name:lower()] = true
                end
            end
        else
            for name, isSelected in pairs(selected) do
                if isSelected and type(name) == "string" then
                    whitelist[name:lower()] = true
                end
            end
        end
    end
})

Notification:AddToggle("EntityNotifier", {
    Text = "Entity Notifier",
    Default = false,
    Callback = function(value)
        entityNotifierEnabled = value
    end
})

Notification:AddToggle("ChatNotifier", {
    Text = "Chat Notifier",
    Default = false,
    Callback = function(value)
        chatNotifierEnabled = value
    end
})

workspace.ChildAdded:Connect(function(child)
    local msg = entities[child.Name]
    if not msg then return end
    if not whitelist[child.Name:lower()] then return end
    if entityNotifierEnabled then
        Library:Notify(msg, 5, 6026984224)
    end
    if chatNotifierEnabled then
        local chatService = game:GetService("TextChatService")
        local general = chatService.TextChannels and chatService.TextChannels.RBXGeneral
        if general then
            general:SendAsync(msg)
        end
    end
end)

local Auto = Tabs.Main:AddRightGroupbox("Auto")

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local entityNames = {"RushMoving", "AmbushMoving", "BackdoorRush", "A60", "A120", "GlitchRush", "GlitchAmbush"}
local autoClosetEnabled = false

local function GetNearestEntity()
    local nearestDist = 150
    local nearest = nil
    for _, obj in ipairs(Workspace:GetChildren()) do
        if table.find(entityNames, obj.Name) and obj:IsA("Model") then
            local pos = obj.PrimaryPart and obj.PrimaryPart.Position or obj:GetModelCFrame().Position
            local dist = (pos - hrp.Position).Magnitude
            if dist <= nearestDist then
                nearestDist = dist
                nearest = obj
            end
        end
    end
    return nearest
end

local function GetNearestWardrobe()
    local nearestWardrobe = nil
    local nearestDist = 14.5
    for _, room in ipairs(Workspace.CurrentRooms:GetChildren()) do
        local assets = room:FindFirstChild("Assets")
        if assets then
            for _, asset in ipairs(assets:GetChildren()) do
                local prompt = asset:FindFirstChild("HidePrompt")
                local part = asset:IsA("BasePart") and asset or asset:FindFirstChildWhichIsA("BasePart")
                if prompt and part and asset.Name:lower():find("wardrobe") then
                    local dist = (part.Position - hrp.Position).Magnitude
                    if dist <= nearestDist then
                        nearestDist = dist
                        nearestWardrobe = prompt
                    end
                end
            end
        end
    end
    return nearestWardrobe
end

local lastPress = 0

local function PressUnhideButton()
    if GetNearestEntity() then return end
    if tick() - lastPress < 1 then return end

    local mainUI = player.PlayerGui:FindFirstChild("MainUI")
    if not mainUI then return end
    local mainFrame = mainUI:FindFirstChild("MainFrame")
    if not mainFrame then return end
    local button = mainFrame:FindFirstChild("ButtonUnhide")
    if button and button.Visible then
        pcall(function()
            firesignal(button.MouseButton1Down)
        end)
        lastPress = tick()
    end
end

RunService.RenderStepped:Connect(function()
    if not autoClosetEnabled then return end

    local entity = GetNearestEntity()
    if entity then
        local wardrobePrompt = GetNearestWardrobe()
        if wardrobePrompt then
            fireproximityprompt(wardrobePrompt)
        end
    else
        PressUnhideButton()
    end
end)

Auto:AddToggle("AutoCloset", {
    Text = "Auto Closet",
    Default = false,
    Callback = function(Value)
        autoClosetEnabled = Value
    end
})

local Exploits = Tabs.Exploits:AddLeftGroupbox("Exploits")

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

Exploits:AddToggle("SpeedBypass", {
    Text = "Speed Bypass",
    Default = false,
    Callback = function(enabled)
        if enabled then
            Options.SpeedSlider:SetMax(100)
            Options.SpeedSlider:SetMin(15)
            Options.FlightSpeedSlider:SetMax(100)
            Options.FlightSpeedSlider:SetMin(15)
        else
            Options.SpeedSlider:SetMax(21)
            Options.SpeedSlider:SetMin(15)
            Options.FlightSpeedSlider:SetMax(21)
            Options.FlightSpeedSlider:SetMin(15)
        end

        local Character = Player.Character or Player.CharacterAdded:Wait()
        if enabled then
            if Character:FindFirstChild("ClonedCollision") then return end

            local Collision = Character:WaitForChild("Collision", 9e9)
            local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 9e9)
            local CollisionClone = Collision:Clone()
            CollisionClone.Name = "ClonedCollision"
            CollisionClone.Parent = Character
            CollisionClone.CanCollide = false
            CollisionClone.Massless = true

            if CollisionClone:FindFirstChild("CollisionCrouch") then
                CollisionClone.CollisionCrouch:Destroy()
            end

            Player.CharacterAdded:Connect(function(NewCharacter)
                task.wait(1)
                Character = NewCharacter
                Collision = Character:WaitForChild("Collision", 9e9)
                HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 9e9)
                CollisionClone = Collision:Clone()
                CollisionClone.Name = "ClonedCollision"
                CollisionClone.Parent = Character
                CollisionClone.CanCollide = false
                CollisionClone.Massless = true
                if CollisionClone:FindFirstChild("CollisionCrouch") then
                    CollisionClone.CollisionCrouch:Destroy()
                end
            end)

            task.spawn(function()
                while enabled and CollisionClone and Character:FindFirstChild("HumanoidRootPart") do
                    if Character.HumanoidRootPart.Anchored then
                        CollisionClone.Massless = true
                        HumanoidRootPart.Massless = false
                        HumanoidRootPart.RootPriority = 0
                        task.wait(1)
                    else
                        CollisionClone.Massless = not CollisionClone.Massless
                        HumanoidRootPart.Massless = not HumanoidRootPart.Massless
                        HumanoidRootPart.RootPriority = (HumanoidRootPart.Massless and 1 or 0)
                        task.wait(0.215)
                    end
                end
                if not enabled and CollisionClone then
                    CollisionClone:Destroy()
                end
            end)
        end
    end
})

local UserInputService = game:GetService("UserInputService")
local Player = game.Players.LocalPlayer
local flyjump = nil

Exploits:AddToggle("InfiniteJump", {
    Text = "Infinite Jump",
    Default = false,
    Callback = function(Value)
if Value then
if flyjump then
    flyjump:Disconnect()
end

flyjump = UserInputService.JumpRequest:Connect(function()
    local character = Player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)
else
if flyjump then
   flyjump:Disconnect()
   flyjump = nil
end
end
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local connection = nil

Exploits:AddToggle("AnticheatManipulation", {
    Text = "Anticheat Manipulation",
    Default = false,
    Callback = function(enabled)
        if enabled then
            if not connection then
                connection = RunService.RenderStepped:Connect(function()
                    if character and character.Parent then
                        character:PivotTo(character:GetPivot() * CFrame.new(0, 0, 1000))
                    end
                end)
            end
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end
}):AddKeyPicker('AnticheatManipulationKeybind', {
    Default = 'V',
    SyncToggleState = true,
    Mode = Library.IsMobile and 'Toggle' or 'Hold',
    Text = 'Anticheat Manipulation',
    NoUI = false,
    Callback = function(Value) end,
    ChangedCallback = function(New) end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local spam = false

Exploits:AddToggle("SpamOthersTools", {
    Text = "Spam Others Tools",
    Default = false,
    Callback = function(Value)
        spam = Value

        if spam then
            task.spawn(function()
                while spam do
                    for _, player in ipairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer then
                            local backpack = player:FindFirstChild("Backpack")
                            if backpack then
                                for _, tool in ipairs(backpack:GetChildren()) do
                                    if tool:IsA("Tool") then
                                        local remote = tool:FindFirstChildOfClass("RemoteEvent")
                                        if remote then
                                            remote:FireServer()
                                        end
                                    end
                                end
                            end

                            local character = player.Character
                            if character then
                                for _, tool in ipairs(character:GetChildren()) do
                                    if tool:IsA("Tool") then
                                        local remote = tool:FindFirstChildOfClass("RemoteEvent")
                                        if remote then
                                            remote:FireServer()
                                        end
                                    end
                                end
                            end
                        end
                    end
                    task.wait()
                end
            end)
        end
    end
})

local Anti = Tabs.Exploits:AddLeftGroupbox("Anti")

local eyesConnection
local eyesLoopRunning = false
local stopEyesLoop = false

Anti:AddToggle("AntiEyes", {
    Text = "Anti Eyes",
    Default = false,
    Callback = function(Value)
        if Value then
            eyesConnection = workspace.ChildAdded:Connect(function(child)
                if child.Name == "Eyes" and not eyesLoopRunning then
                    eyesLoopRunning = true
                    stopEyesLoop = false

                    task.spawn(function()
                        local remote = game.ReplicatedStorage:FindFirstChild("RemotesFolder") and game.ReplicatedStorage.RemotesFolder:FindFirstChild("MotorReplication")
                        if not remote then
                            warn("MotorReplication remote not found!")
                            return
                        end
                        
                        while workspace:FindFirstChild("Eyes") and not stopEyesLoop do
                            remote:FireServer(-649)
                            task.wait()
                        end

                        eyesLoopRunning = false
                    end)
                end
            end)
        else
            stopEyesLoop = true
            eyesLoopRunning = false

            if eyesConnection and eyesConnection.Connected then
                eyesConnection:Disconnect()
                eyesConnection = nil
            end
        end
    end
})

local LookmanConnection
local LookmanLoopRunning = false
local stopLookmanLoop = false

Anti:AddToggle("AntiLookman", {
    Text = "Anti Lookman",
    Default = false,
    Callback = function(Value)
        if Value then
            LookmanConnection = workspace.ChildAdded:Connect(function(child)
                if child.Name == "BackdoorLookman" and not LookmanLoopRunning then
                    LookmanLoopRunning = true
                    stopLookmanLoop = false

                    task.spawn(function()
                        local remote = game.ReplicatedStorage:FindFirstChild("RemotesFolder") and game.ReplicatedStorage.RemotesFolder:FindFirstChild("MotorReplication")
                        if not remote then
                            warn("MotorReplication remote not found!")
                            return
                        end
                        
                        while workspace:FindFirstChild("BackdoorLookman") and not stopLookmanLoop do
                            remote:FireServer(-649)
                            task.wait()
                        end
                        LookmanLoopRunning = false
                    end)
                end
            end)
        else
            stopLookmanLoop = true
            LookmanLoopRunning = false

            if LookmanConnection and LookmanConnection.Connected then
                LookmanConnection:Disconnect()
                LookmanConnection = nil
            end
        end
    end
})

local dupeConnection
local modifiedParts = {}
local modifiedPrompts = {}

local function disableDoorFake(model)
    for _, descendant in ipairs(model:GetDescendants()) do
        if descendant:IsA("BasePart") then
            table.insert(modifiedParts, {
                part = descendant,
                canTouch = descendant.CanTouch,
                canCollide = descendant.CanCollide,
                canQuery = descendant.CanQuery
            })
            descendant.CanTouch = false
            descendant.CanCollide = false
            descendant.CanQuery = false
        elseif descendant:IsA("ProximityPrompt") then
            table.insert(modifiedPrompts, {
                prompt = descendant,
                enabled = descendant.Enabled
            })
            descendant.Enabled = false
        end
    end

    model.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("BasePart") then
            table.insert(modifiedParts, {
                part = descendant,
                canTouch = descendant.CanTouch,
                canCollide = descendant.CanCollide,
                canQuery = descendant.CanQuery
            })
            descendant.CanTouch = false
            descendant.CanCollide = false
            descendant.CanQuery = false
        elseif descendant:IsA("ProximityPrompt") then
            table.insert(modifiedPrompts, {
                prompt = descendant,
                enabled = descendant.Enabled
            })
            descendant.Enabled = false
        end
    end)
end

Anti:AddToggle("AntiDupe", {
    Text = "Anti Dupe",
    Default = false,
    Callback = function(Value)
        if Value then
            modifiedParts = {}
            modifiedPrompts = {}

            for _, descendant in ipairs(workspace:GetDescendants()) do
                if descendant:IsA("Model") and descendant.Name == "DoorFake" then
                    disableDoorFake(descendant)
                end
            end

            dupeConnection = workspace.DescendantAdded:Connect(function(child)
                if child:IsA("Model") and child.Name == "DoorFake" then
                    disableDoorFake(child)
                end
            end)
        else
            for _, data in ipairs(modifiedParts) do
                if data.part and data.part:IsA("BasePart") then
                    data.part.CanTouch = data.canTouch
                    data.part.CanCollide = data.canCollide
                    data.part.CanQuery = data.canQuery
                end
            end
            for _, data in ipairs(modifiedPrompts) do
                if data.prompt and data.prompt:IsA("ProximityPrompt") then
                    data.prompt.Enabled = data.enabled
                end
            end

            modifiedParts = {}
            modifiedPrompts = {}

            if dupeConnection and dupeConnection.Connected then
                dupeConnection:Disconnect()
                dupeConnection = nil
            end
        end
    end
})

local sideroomConnection
local modifiedParts = {}
local modifiedPrompts = {}

Anti:AddToggle("AntiVacuum", {
    Text = "Anti Vacuum",
    Default = false,
    Callback = function(Value)
        if Value then
            modifiedParts = {}
            modifiedPrompts = {}

            for _, descendant in ipairs(workspace:GetDescendants()) do
                if descendant:IsA("Model") and descendant.Name == "SideroomSpace" then
                    for _, obj in ipairs(descendant:GetDescendants()) do
                        if obj:IsA("BasePart") then
                            if obj.CanTouch ~= false then
                                table.insert(modifiedParts, obj)
                                obj.CanTouch = false
                            end
                        elseif obj:IsA("ProximityPrompt") then
                            if obj.Enabled ~= false then
                                table.insert(modifiedPrompts, obj)
                                obj.Enabled = false
                            end
                        end
                    end

                    descendant.DescendantAdded:Connect(function(obj)
                        if obj:IsA("BasePart") then
                            if obj.CanTouch ~= false then
                                table.insert(modifiedParts, obj)
                                obj.CanTouch = false
                            end
                        elseif obj:IsA("ProximityPrompt") then
                            if obj.Enabled ~= false then
                                table.insert(modifiedPrompts, obj)
                                obj.Enabled = false
                            end
                        end
                    end)
                end
            end

            sideroomConnection = workspace.DescendantAdded:Connect(function(child)
                if child:IsA("Model") and child.Name == "SideroomSpace" then
                    for _, obj in ipairs(child:GetDescendants()) do
                        if obj:IsA("BasePart") then
                            if obj.CanTouch ~= false then
                                table.insert(modifiedParts, obj)
                                obj.CanTouch = false
                            end
                        elseif obj:IsA("ProximityPrompt") then
                            if obj.Enabled ~= false then
                                table.insert(modifiedPrompts, obj)
                                obj.Enabled = false
                            end
                        end
                    end

                    child.DescendantAdded:Connect(function(obj)
                        if obj:IsA("BasePart") then
                            if obj.CanTouch ~= false then
                                table.insert(modifiedParts, obj)
                                obj.CanTouch = false
                            end
                        elseif obj:IsA("ProximityPrompt") then
                            if obj.Enabled ~= false then
                                table.insert(modifiedPrompts, obj)
                                obj.Enabled = false
                            end
                        end
                    end)
                end
            end)
        else
            for _, part in ipairs(modifiedParts) do
                if part and part:IsA("BasePart") then
                    part.CanTouch = true
                end
            end

            for _, prompt in ipairs(modifiedPrompts) do
                if prompt and prompt:IsA("ProximityPrompt") then
                    prompt.Enabled = true
                end
            end

            modifiedParts = {}
            modifiedPrompts = {}

            if sideroomConnection and sideroomConnection.Connected then
                sideroomConnection:Disconnect()
                sideroomConnection = nil
            end
        end
    end
})

local snareConnection
local snareModifiedParts = {}

Anti:AddToggle("AntiSnare", {
    Text = "Anti Snare",
    Default = false,
    Callback = function(Value)
        if Value then
            snareModifiedParts = {}

            for _, descendant in ipairs(workspace:GetDescendants()) do
                if descendant:IsA("Model") and descendant.Name == "Snare" then
                    for _, part in ipairs(descendant:GetDescendants()) do
                        if part:IsA("BasePart") then
                            table.insert(snareModifiedParts, {
                                part = part,
                                canTouch = part.CanTouch,
                                canCollide = part.CanCollide,
                                canQuery = part.CanQuery
                            })
                            part.CanTouch = false
                            part.CanCollide = false
                            part.CanQuery = false
                        end
                    end

                    descendant.DescendantAdded:Connect(function(newPart)
                        if newPart:IsA("BasePart") then
                            table.insert(snareModifiedParts, {
                                part = newPart,
                                canTouch = newPart.CanTouch,
                                canCollide = newPart.CanCollide,
                                canQuery = newPart.CanQuery
                            })
                            newPart.CanTouch = false
                            newPart.CanCollide = false
                            newPart.CanQuery = false
                        end
                    end)
                end
            end

            snareConnection = workspace.DescendantAdded:Connect(function(child)
                if child:IsA("Model") and child.Name == "Snare" then
                    for _, part in ipairs(child:GetDescendants()) do
                        if part:IsA("BasePart") then
                            table.insert(snareModifiedParts, {
                                part = part,
                                canTouch = part.CanTouch,
                                canCollide = part.CanCollide,
                                canQuery = part.CanQuery
                            })
                            part.CanTouch = false
                            part.CanCollide = false
                            part.CanQuery = false
                        end
                    end

                    child.DescendantAdded:Connect(function(newPart)
                        if newPart:IsA("BasePart") then
                            table.insert(snareModifiedParts, {
                                part = newPart,
                                canTouch = newPart.CanTouch,
                                canCollide = newPart.CanCollide,
                                canQuery = newPart.CanQuery
                            })
                            newPart.CanTouch = false
                            newPart.CanCollide = false
                            newPart.CanQuery = false
                        end
                    end)
                end
            end)
        else
            for _, data in ipairs(snareModifiedParts) do
                if data.part and data.part:IsA("BasePart") then
                    data.part.CanTouch = data.canTouch
                    data.part.CanCollide = data.canCollide
                    data.part.CanQuery = data.canQuery
                end
            end

            snareModifiedParts = {}

            if snareConnection and snareConnection.Connected then
                snareConnection:Disconnect()
                snareConnection = nil
            end
        end
    end
})

local eggDisabled = false
local connection

local function updateEggs()
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj.Name == "GloomEgg" then
			local egg = obj:FindFirstChild("Egg", true)
			if egg then
				egg.CanTouch = not eggDisabled
			end
		end
	end
end

local function onAdded(desc)
	if eggDisabled and desc.Name == "GloomEgg" then
		local egg = desc:FindFirstChild("Egg", true)
		if egg then
			egg.CanTouch = false
		end
	end
end

Anti:AddToggle("AntiGloomEgg", {
	Text = "Anti GloomEgg",
	Default = false,
	Callback = function(state)
		eggDisabled = state
		updateEggs()
		if state then
			if not connection then
				connection = workspace.DescendantAdded:Connect(onAdded)
			end
		else
			if connection then
				connection:Disconnect()
				connection = nil
			end
			updateEggs()
		end
	end
})

getgenv().replacement = "true"
getgenv().antiscreech = false

local event = game:GetService("ReplicatedStorage"):WaitForChild("RemotesFolder"):WaitForChild("Screech")

local namecall
namecall = hookmetamethod(game, "__namecall", function(self, ...)
    local args = {...}
    local method = getnamecallmethod()

    if method == "FireServer" and self == event and getgenv().antiscreech then
        args[1] = getgenv().replacement
        return namecall(self, unpack(args))
    end

    return namecall(self, ...)
end)

Anti:AddToggle("AntiScreech", {
    Text = "Anti Screech",
    Default = false,
    Callback = function(Value)
        getgenv().antiscreech = Value
    end
})

local GiggleTouchDisabled = false
local connection

local function updateGiggleCeilingHitboxes()
	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name == "GiggleCeiling" then
			local hitbox = model:FindFirstChild("Hitbox", true)
			if hitbox and hitbox:IsA("BasePart") then
				hitbox.CanTouch = not GiggleTouchDisabled
			end
		end
	end
end

local function onDescendantAdded(desc)
	if GiggleTouchDisabled and desc:IsA("Model") and desc.Name == "GiggleCeiling" then
		local hitbox = desc:FindFirstChild("Hitbox", true)
		if hitbox and hitbox:IsA("BasePart") then
			hitbox.CanTouch = false
		end
	end
end

Anti:AddToggle("AntiGiggle", {
	Text = "Anti Giggle",
	Default = false,
	Callback = function(state)
		GiggleTouchDisabled = state
		updateGiggleCeilingHitboxes()
		if state then
			if not connection then
				connection = workspace.DescendantAdded:Connect(onDescendantAdded)
			end
		else
			if connection then
				connection:Disconnect()
				connection = nil
			end
			updateGiggleCeilingHitboxes()
		end
	end
})

local chandelierConnection
local chandelierModifiedParts = {}

Anti:AddToggle("AntiChandelierObstruction", {
    Text = "Anti ChandelierObstruction",
    Default = false,
    Callback = function(Value)
        if Value then
            chandelierModifiedParts = {}

            for _, descendant in ipairs(workspace:GetDescendants()) do
                if descendant:IsA("Model") and descendant.Name == "ChandelierObstruction" then
                    for _, part in ipairs(descendant:GetDescendants()) do
                        if part:IsA("BasePart") then
                            table.insert(chandelierModifiedParts, {
                                part = part,
                                canTouch = part.CanTouch,
                                canCollide = part.CanCollide,
                                canQuery = part.CanQuery
                            })
                            part.CanTouch = false
                            part.CanCollide = false
                            part.CanQuery = false
                        end
                    end

                    descendant.DescendantAdded:Connect(function(newPart)
                        if newPart:IsA("BasePart") then
                            table.insert(chandelierModifiedParts, {
                                part = newPart,
                                canTouch = newPart.CanTouch,
                                canCollide = newPart.CanCollide,
                                canQuery = newPart.CanQuery
                            })
                            newPart.CanTouch = false
                            newPart.CanCollide = false
                            newPart.CanQuery = false
                        end
                    end)
                end
            end

            chandelierConnection = workspace.DescendantAdded:Connect(function(child)
                if child:IsA("Model") and child.Name == "ChandelierObstruction" then
                    for _, part in ipairs(child:GetDescendants()) do
                        if part:IsA("BasePart") then
                            table.insert(chandelierModifiedParts, {
                                part = part,
                                canTouch = part.CanTouch,
                                canCollide = part.CanCollide,
                                canQuery = part.CanQuery
                            })
                            part.CanTouch = false
                            part.CanCollide = false
                            part.CanQuery = false
                        end
                    end

                    child.DescendantAdded:Connect(function(newPart)
                        if newPart:IsA("BasePart") then
                            table.insert(chandelierModifiedParts, {
                                part = newPart,
                                canTouch = newPart.CanTouch,
                                canCollide = newPart.CanCollide,
                                canQuery = newPart.CanQuery
                            })
                            newPart.CanTouch = false
                            newPart.CanCollide = false
                            newPart.CanQuery = false
                        end
                    end)
                end
            end)
        else
            for _, data in ipairs(chandelierModifiedParts) do
                if data.part and data.part:IsA("BasePart") then
                    data.part.CanTouch = data.canTouch
                    data.part.CanCollide = data.canCollide
                    data.part.CanQuery = data.canQuery
                end
            end

            chandelierModifiedParts = {}

            if chandelierConnection and chandelierConnection.Connected then
                chandelierConnection:Disconnect()
                chandelierConnection = nil
            end
        end
    end
})

local seekArmConnection
local seekArmModifiedParts = {}

Anti:AddToggle("AntiSeekArm", {
    Text = "Anti Seek Arm",
    Default = false,
    Callback = function(Value)
        if Value then
            seekArmModifiedParts = {}

            for _, descendant in ipairs(workspace:GetDescendants()) do
                if descendant:IsA("Model") and descendant.Name == "Seek_Arm" then
                    for _, part in ipairs(descendant:GetDescendants()) do
                        if part:IsA("BasePart") then
                            table.insert(seekArmModifiedParts, {
                                part = part,
                                canTouch = part.CanTouch,
                                canCollide = part.CanCollide,
                                canQuery = part.CanQuery
                            })
                            part.CanTouch = false
                            part.CanCollide = false
                            part.CanQuery = false
                        end
                    end

                    descendant.DescendantAdded:Connect(function(newPart)
                        if newPart:IsA("BasePart") then
                            table.insert(seekArmModifiedParts, {
                                part = newPart,
                                canTouch = newPart.CanTouch,
                                canCollide = newPart.CanCollide,
                                canQuery = newPart.CanQuery
                            })
                            newPart.CanTouch = false
                            newPart.CanCollide = false
                            newPart.CanQuery = false
                        end
                    end)
                end
            end

            seekArmConnection = workspace.DescendantAdded:Connect(function(child)
                if child:IsA("Model") and child.Name == "Seek_Arm" then
                    for _, part in ipairs(child:GetDescendants()) do
                        if part:IsA("BasePart") then
                            table.insert(seekArmModifiedParts, {
                                part = part,
                                canTouch = part.CanTouch,
                                canCollide = part.CanCollide,
                                canQuery = part.CanQuery
                            })
                            part.CanTouch = false
                            part.CanCollide = false
                            part.CanQuery = false
                        end
                    end

                    child.DescendantAdded:Connect(function(newPart)
                        if newPart:IsA("BasePart") then
                            table.insert(seekArmModifiedParts, {
                                part = newPart,
                                canTouch = newPart.CanTouch,
                                canCollide = newPart.CanCollide,
                                canQuery = newPart.CanQuery
                            })
                            newPart.CanTouch = false
                            newPart.CanCollide = false
                            newPart.CanQuery = false
                        end
                    end)
                end
            end)
        else
            for _, data in ipairs(seekArmModifiedParts) do
                if data.part and data.part:IsA("BasePart") then
                    data.part.CanTouch = data.canTouch
                    data.part.CanCollide = data.canCollide
                    data.part.CanQuery = data.canQuery
                end
            end

            seekArmModifiedParts = {}

            if seekArmConnection and seekArmConnection.Connected then
                seekArmConnection:Disconnect()
                seekArmConnection = nil
            end
        end
    end
})

getgenv().replacement = "didnt"
getgenv().antiA90Enabled = false

local event = game:GetService("ReplicatedStorage"):WaitForChild("RemotesFolder"):WaitForChild("A90")

local namecall
namecall = hookmetamethod(game, "__namecall", function(self, ...)
    local args = {...}
    local method = getnamecallmethod()

    if method == "FireServer" and self == event and getgenv().antiA90Enabled then
        args[1] = getgenv().replacement
        return namecall(self, unpack(args))
    end

    return namecall(self, ...)
end)

Anti:AddToggle("AntiA90", {
    Text = "Anti A90",
    Default = false,
    Callback = function(Value)
        getgenv().antiA90Enabled = Value
    end
})

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CrouchRemote = ReplicatedStorage:WaitForChild("RemotesFolder"):WaitForChild("Crouch")

local crouchConnection = nil

Anti:AddToggle("AntiFigureHearing", {
    Text = "Anti Figure Hearing",
    Default = false,
    Callback = function(Value)
        if Value then
            crouchConnection = RunService.Heartbeat:Connect(function()
                CrouchRemote:FireServer(true)
            end)
        else
            if crouchConnection then
                crouchConnection:Disconnect()
                crouchConnection = nil
            end
        end
    end
})

local Puzzles = Tabs.Exploits:AddRightGroupbox("Puzzles")

local RepStore = game:GetService("ReplicatedStorage")
local PS = game:GetService("Players")
local RunSvc = game:GetService("RunService")

local LocalPlayer = PS.LocalPlayer
local PlayerGui   = LocalPlayer:WaitForChild("PlayerGui")

local function findPL()
	for _, inst in ipairs(RepStore:GetDescendants()) do
		if inst.Name == "PL" and (inst:IsA("RemoteEvent") or inst:IsA("RemoteFunction")) then
			return inst, inst:IsA("RemoteFunction")
		end
	end
end

local PL, isFunction = findPL()

local function parsePaper(paper, hintsContainer)
	local children = paper.UI:GetChildren()
	local map, order = {}, {}

	for _, c in ipairs(children) do
		local idx = tonumber(c.Name)
		if idx then
			local key = c.ImageRectOffset.X .. "_" .. c.ImageRectOffset.Y
			map[key] = { idx, "" }
			order[idx] = key
		end
	end

	if hintsContainer then
		for _, ic in ipairs(hintsContainer:GetChildren()) do
			if ic.Name == "Icon" then
				local key = ic.ImageRectOffset.X .. "_" .. ic.ImageRectOffset.Y
				local entry = map[key]
				if entry then
					local lbl = ic:FindFirstChildWhichIsA("TextLabel")
					if lbl then entry[2] = lbl.Text end
				end
			end
		end
	end

	local parts = {}
	for i = 1, #order do
		parts[i] = map[order[i]][2]
	end
	return table.concat(parts)
end

local heartbeatConn
local throttle = 0
local seenPapers = {}
local lastCodes = {}

local function stopAll()
	if heartbeatConn then
		heartbeatConn:Disconnect()
		heartbeatConn = nil
	end
	throttle = 0
	table.clear(seenPapers)
	table.clear(lastCodes)
end

Puzzles:AddToggle("AutoLibraryCode", {
	Text = "Auto Solve Library Code",
	Default = false,
	Callback = function(enabled)
		stopAll()
		if not enabled then return end
		heartbeatConn = RunSvc.Heartbeat:Connect(function(dt)
			throttle = throttle + dt
			if throttle < 0.3 then return end
			throttle = 0

			local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
			local hints = PlayerGui:FindFirstChild("PermUI") and PlayerGui.PermUI:FindFirstChild("Hints")

			for _, d in ipairs(char:GetDescendants()) do
				if (d.Name == "LibraryHintPaper" or d.Name == "LibraryHintPaperHard") and not seenPapers[d] then
					seenPapers[d] = true
					local code = parsePaper(d, hints)
					lastCodes[d] = code
					Library:Notify("Code: " .. code, 5, 6026984224)
				end
			end

			for paper in pairs(seenPapers) do
				if not paper.Parent then
					seenPapers[paper] = nil
					lastCodes[paper] = nil
				else
					local code = parsePaper(paper, hints)
					if code ~= lastCodes[paper] then
						lastCodes[paper] = code
						Library:Notify("Code: " .. code, 5, 6026984224)
						if isFunction then
							PL:InvokeServer(code)
						else
							PL:FireServer(code)
						end
					end
				end
			end
		end)
	end,
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local GameData = ReplicatedStorage:WaitForChild("GameData")
local LatestRoomVal = GameData:WaitForChild("LatestRoom")

local BreakerRemote
for _, desc in ipairs(ReplicatedStorage:GetDescendants()) do
	if desc.Name == "EBF" then
		BreakerRemote = desc
		break
	end
end

local stopSignal = true

Puzzles:AddToggle("AutoBreakerSolver", {
	Text = "Auto Breaker Solve",
	Default = false,
	Callback = function(on)
		stopSignal = not on
		if on and BreakerRemote then
			task.spawn(function()
				while not stopSignal do
					local roomName = tostring(LatestRoomVal.Value)
					local room = Workspace.CurrentRooms:FindFirstChild(roomName)
					if room then
						local door = room:FindFirstChild("DoorToBreakDown")
						if door then
							BreakerRemote:FireServer()
						end
					end
					task.wait()
				end
			end)
		end
	end,
})

local Trolling = Tabs.Exploits:AddRightGroupbox("Trolling")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remote = ReplicatedStorage:WaitForChild("RemotesFolder"):WaitForChild("MotorReplication")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local MotorBreakerEnabled = false
local MotorBreakerThread = nil

Trolling:AddToggle("MotorReplicationBreaker", {
    Text = "MotorReplication Breaker",
    Default = false,
    Callback = function(Value)
        MotorBreakerEnabled = Value

        if MotorBreakerThread then
            task.cancel(MotorBreakerThread)
            MotorBreakerThread = nil
        end

        if MotorBreakerEnabled then
            MotorBreakerThread = task.spawn(function()
                while MotorBreakerEnabled do
                    local randomNum = math.random(1, 10000)
                    local args = { randomNum }
                    pcall(function()
                        Remote:FireServer(unpack(args))
                    end)
                    task.wait()
                end
            end)
        end
    end
})

local InfiniteItems = Tabs.Exploits:AddRightGroupbox("Infinite Items")

local infiniteItemsEnabled = false
local itemsList = {"Lockpick", "SkeletonKey"}

local Player = game.Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local function DropTools()
	for _, tool in pairs(Player.Character:GetChildren()) do
		if tool:IsA("Tool") and table.find(itemsList, tool.Name) then
			local remote = ReplicatedStorage:WaitForChild("RemotesFolder"):WaitForChild("DropItem")
			remote:FireServer(tool)
		end
	end
end

local function UseItemPrompt()
	local dropsFolder = Workspace:FindFirstChild("Drops")
	if not dropsFolder then return end

	for _, itemName in ipairs(itemsList) do
		local itemModel = dropsFolder:FindFirstChild(itemName)
		if itemModel then
			local prompt = itemModel:FindFirstChildWhichIsA("ProximityPrompt")
			if prompt then
				fireproximityprompt(prompt)
			end
		end
	end
end

local function PrepareBeforePrompt()
	DropTools()
	UseItemPrompt()
end

local function MonitorPrompt(prompt)
	if not prompt:IsA("ProximityPrompt") then return end

	local holdTime = prompt.HoldDuration or 0
	prompt.PromptButtonHoldBegan:Connect(function()
		if infiniteItemsEnabled then
			task.delay(math.max(holdTime - 0.20, 0), function()
				PrepareBeforePrompt()
			end)
		end
	end)
end

for _, obj in pairs(Workspace:GetDescendants()) do
	MonitorPrompt(obj)
end

Workspace.DescendantAdded:Connect(function(descendant)
	MonitorPrompt(descendant)
end)

InfiniteItems:AddToggle("InfiniteItems", {
	Text = "Infinite Lockpick / Skeleton Key",
	Default = false,
	Callback = function(Value)
		infiniteItemsEnabled = Value
	end
})

local ESP = Tabs.ESP:AddLeftGroupbox("ESP")

local ESPLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/LuaLandy/Scripts/refs/heads/main/ESPLibrary/ESPLibrary.lua"))()

local ESPLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/LuaLandy/Scripts/refs/heads/main/ESPLibrary/ESPLibrary.lua"))()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LatestRoom = ReplicatedStorage.GameData.LatestRoom
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local ESPDoorsEnabled = false
local ESPItemsEnabled = false
local ESPEntitiesEnabled = false
local ESPPuzzlesEnabled = false
local ESPTracersEnabled = false
local RainbowEnabled = false
local RainbowConnection

local DoorColor = Color3.new(1, 1, 1)
local ItemColor = Color3.fromRGB(0, 255, 247)
local EntityColor = Color3.new(1, 0, 0)
local PuzzleColor = Color3.new(0, 1, 0)

local Items = {
    Flashlight = "Flashlight",
    Lockpick = "Lockpick",
    Vitamins = "Vitamins",
    Bandage = "Bandage",
    StarVial = "Star Vial",
    StarBottle = "Star Bottle",
    StarJug = "Star Jug",
    Shakelight = "Shakelight",
    Straplight = "Straplight",
    Bulklight = "Bulklight",
    Battery = "Battery",
    Candle = "Candle",
    Crucifix = "Crucifix",
    CrucifixWall = "Crucifix",
    Glowsticks = "Glowsticks",
    SkeletonKey = "Skeleton Key",
    Candy = "Candy",
    ShieldMini = "Mini Shield",
    ShieldBig = "Big Shield",
    BandagePack = "Bandage Pack",
    BatteryPack = "Battery Pack",
    RiftCandle = "Rift Candle",
    LaserPointer = "Laser Pointer",
    HolyGrenade = "Holy Grenade",
    Shears = "Shears",
    Smoothie = "Smoothie",
    Cheese = "Cheese",
    Bread = "Bread",
    AlarmClock = "Alarm Clock",
    RiftSmoothie = "Rift Smoothie",
    GweenSoda = "Gween Soda",
    GlitchCub = "Glitch Cube"
}

local Entities = {
    RushMoving = "Rush",
    AmbushMoving = "Ambush",
    Eyes = "Eyes",
    A60 = "A60",
    A120 = "A120",
    BackdoorRush = "Blitz",
    BackdoorLookman = "Lookman",
    Screech = "Screech",
    GiggleCeiling = "Giggle",
    GlitchRush = "Glitch Rush",
    GlitchAmbush = "Glitch Ambush",
    GlitchedScreech = "Glitched Screech",
    SeekMoving = "Seek",
    SeekMovingNewClone = "Seek",
    JeffTheKiller = "Jeff The Killer"
}

local Puzzles = {
    KeyObtain = "Key",
    LeverForGate = "Lever",
    LiveHintBook = "Book",
    LiveBreakerPolePickup = "Breaker",
    FuseObtain = "Fuse",
    MinesGenerator = "Generator",
    TimerLever = "Timer Lever"
}

local ActiveESP = {}

local function getRoom()
    if not workspace:FindFirstChild("CurrentRooms") then return nil end
    local ok, val = pcall(function() return tostring(LatestRoom.Value) end)
    if not ok then return nil end
    return workspace.CurrentRooms:FindFirstChild(val)
end

local function getAdornee(model)
    if not model then return nil end
    local part = model:FindFirstChild("Door") or model:FindFirstChildWhichIsA("BasePart")
    return part
end

local function AddESPForModel(model, color, name)
    if ActiveESP[model] then
        local part = ActiveESP[model]
        if ESPLibrary.UpdateObjectColor then
            ESPLibrary:UpdateObjectColor(part, color)
        else
            ESPLibrary:RemoveESP(part)
            ESPLibrary:AddESP({ Object = part, Text = name, Color = color })
            ActiveESP[model] = part
        end
        return
    end
    local part = getAdornee(model)
    if not part then return end
    ESPLibrary:AddESP({ Object = part, Text = name, Color = color })
    ActiveESP[model] = part
end

local function RemoveESPForModel(model)
    local part = ActiveESP[model]
    if part then
        ESPLibrary:RemoveESP(part)
        ActiveESP[model] = nil
    end
end

local function RemoveAllOfCategoryInRoom(check)
    local room = getRoom()
    if not room then return end
    for model, part in pairs(ActiveESP) do
        if model and model.Parent and model:IsDescendantOf(room) and check(model) then
            ESPLibrary:RemoveESP(part)
            ActiveESP[model] = nil
        end
    end
end

local function UpdateRoomESP()
    local room = getRoom()
    if not room then return end
    for model, part in pairs(ActiveESP) do
        if not model or not model.Parent or not model:IsDescendantOf(room) then
            ESPLibrary:RemoveESP(part)
            ActiveESP[model] = nil
        end
    end
    for _, model in ipairs(room:GetDescendants()) do
        if model:IsA("Model") then
            if model.Name == "Door" then
                if ESPDoorsEnabled then
                    AddESPForModel(model, DoorColor, "Door")
                else
                    RemoveESPForModel(model)
                end
            elseif Items[model.Name] then
                if ESPItemsEnabled then
                    AddESPForModel(model, ItemColor, Items[model.Name])
                else
                    RemoveESPForModel(model)
                end
            elseif Puzzles[model.Name] then
                if ESPPuzzlesEnabled then
                    AddESPForModel(model, PuzzleColor, Puzzles[model.Name])
                else
                    RemoveESPForModel(model)
                end
            else
                RemoveESPForModel(model)
            end
        end
    end
end

LatestRoom:GetPropertyChangedSignal("Value"):Connect(UpdateRoomESP)

workspace.DescendantAdded:Connect(function(model)
    task.defer(function()
        local room = getRoom()
        if not room then return end
        if model:IsDescendantOf(room) and model:IsA("Model") then
            if model.Name == "Door" and ESPDoorsEnabled then
                AddESPForModel(model, DoorColor, "Door")
            end
            if Items[model.Name] and ESPItemsEnabled then
                AddESPForModel(model, ItemColor, Items[model.Name])
            end
            if Puzzles[model.Name] and ESPPuzzlesEnabled then
                AddESPForModel(model, PuzzleColor, Puzzles[model.Name])
            end
            if Entities[model.Name] and ESPEntitiesEnabled then
                AddESPForModel(model, EntityColor, Entities[model.Name])
            end
        end
    end)
end)

workspace.DescendantRemoving:Connect(function(model)
    if ActiveESP[model] then
        RemoveESPForModel(model)
    end
end)

ESP:AddToggle("ESPDoors", {
    Text = "ESP Doors",
    Default = false,
    Callback = function(Value)
        ESPDoorsEnabled = Value
        if not Value then
            RemoveAllOfCategoryInRoom(function(m) return m.Name == "Door" end)
        else
            UpdateRoomESP()
        end
    end
}):AddColorPicker("DoorColor", {
    Default = DoorColor,
    Title = "Door Color",
    Transparency = 0,
    Callback = function(c)
        DoorColor = c
        local room = getRoom()
        if not room then return end
        for model, part in pairs(ActiveESP) do
            if model and model:IsDescendantOf(room) and model.Name == "Door" then
                if ESPLibrary.UpdateObjectColor then
                    ESPLibrary:UpdateObjectColor(part, DoorColor)
                else
                    ESPLibrary:RemoveESP(part)
                    AddESPForModel(model, DoorColor, "Door")
                end
            end
        end
    end
})

ESP:AddToggle("ESPItems", {
    Text = "ESP Items",
    Default = false,
    Callback = function(Value)
        ESPItemsEnabled = Value
        if not Value then
            RemoveAllOfCategoryInRoom(function(m) return Items[m.Name] end)
        else
            UpdateRoomESP()
        end
    end
}):AddColorPicker("ItemColor", {
    Default = ItemColor,
    Title = "Item Color",
    Transparency = 0,
    Callback = function(c)
        ItemColor = c
        local room = getRoom()
        if not room then return end
        for model, part in pairs(ActiveESP) do
            if model and model:IsDescendantOf(room) and Items[model.Name] then
                if ESPLibrary.UpdateObjectColor then
                    ESPLibrary:UpdateObjectColor(part, ItemColor)
                else
                    ESPLibrary:RemoveESP(part)
                    AddESPForModel(model, ItemColor, Items[model.Name])
                end
            end
        end
    end
})

ESP:AddToggle("ESPEntities", {
    Text = "ESP Entities",
    Default = false,
    Callback = function(Value)
        ESPEntitiesEnabled = Value
        if not Value then
            RemoveAllOfCategoryInRoom(function(m) return Entities[m.Name] end)
        else
            UpdateRoomESP()
        end
    end
}):AddColorPicker("EntityColor", {
    Default = EntityColor,
    Title = "Entity Color",
    Transparency = 0,
    Callback = function(c)
        EntityColor = c
        local room = getRoom()
        if not room then return end
        for model, part in pairs(ActiveESP) do
            if model and model:IsDescendantOf(room) and Entities[model.Name] then
                if ESPLibrary.UpdateObjectColor then
                    ESPLibrary:UpdateObjectColor(part, EntityColor)
                else
                    ESPLibrary:RemoveESP(part)
                    AddESPForModel(model, EntityColor, Entities[model.Name])
                end
            end
        end
    end
})

ESP:AddToggle("ESPPuzzles", {
    Text = "ESP Puzzles",
    Default = false,
    Callback = function(Value)
        ESPPuzzlesEnabled = Value
        if not Value then
            RemoveAllOfCategoryInRoom(function(m) return Puzzles[m.Name] end)
        else
            UpdateRoomESP()
        end
    end
}):AddColorPicker("PuzzleColor", {
    Default = PuzzleColor,
    Title = "Puzzle Color",
    Transparency = 0,
    Callback = function(c)
        PuzzleColor = c
        local room = getRoom()
        if not room then return end
        for model, part in pairs(ActiveESP) do
            if model and model:IsDescendantOf(room) and Puzzles[model.Name] then
                if ESPLibrary.UpdateObjectColor then
                    ESPLibrary:UpdateObjectColor(part, PuzzleColor)
                else
                    ESPLibrary:RemoveESP(part)
                    AddESPForModel(model, PuzzleColor, Puzzles[model.Name])
                end
            end
        end
    end
})

local ESPSettings = Tabs.ESP:AddRightGroupbox("Settings")

ESPSettings:AddToggle("ESPRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(Value)
        RainbowEnabled = Value
        ESPLibrary:Rainbow(Value)
    end
})

ESPSettings:AddToggle("ESPTracers", {
    Text = "Tracers",
    Default = false,
    Callback = function(Value)
        ESPTracersEnabled = Value
        ESPLibrary:Tracers(Value)
    end
})

ESPSettings:AddSlider("ESPTextSize", {
    Text = "Text Size",
    Default = 14,
    Min = 14,
    Max = 30,
    Rounding = 0,
    Callback = function(Value)
        ESPLibrary:TextSize(Value)
    end
})

local Fonts = {
    "FredokaOne", "Arial", "ArialBold", "Arcade", "Bangers", "BebasNeue", "Code", "CodeBold", "Codystar", "Comic",
    "Cormorant", "Courier", "EBGaramond", "Fantasy", "FiraCode", "FiraSans", "Garamond", "Gotham", "GothamBold",
    "Highway", "Impact", "JetBrainsMono", "Kalam", "Lobster", "LuckiestGuy", "Monospace", "Montserrat", "Notable",
    "Nunito", "OldStandardTT", "Overpass", "Pacifico", "Poppins", "PTSerif", "Raleway", "Roboto", "RobotoBold",
    "RobotoCondensed", "RobotoMono", "Ubuntu", "UbuntuBold", "UbuntuCondensed", "VarelaRound", "VT323",
    "YanoneKaffeesatz", "YesevaOne", "SourceSans", "SourceSansBold", "SourceSansLight", "SourceSansItalic",
    "SourceCodePro", "PressStart2P", "PermanentMarker"
}

ESPSettings:AddDropdown("ESPFont", {
    Values = Fonts,
    Default = 1,
    Multi = false,
    Text = "ESP Font",
    Searchable = true,
    Callback = function(Value)
        ESPLibrary:Font(Enum.Font[Value] or Enum.Font.FredokaOne)
    end
})

local Visual = Tabs.Visual:AddLeftGroupbox("Visual")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

local trail
local rgbLoop
local trailColor = Color3.new(1, 0, 0)

local function createTrail(color)
    if trail then
        trail:Destroy()
    end

    trail = Instance.new("Trail")
    trail.Color = ColorSequence.new(color)
    trail.Lifetime = 2

    trail.Attachment0 = Instance.new("Attachment", rootPart)
    trail.Attachment1 = Instance.new("Attachment", rootPart)

    trail.Attachment0.Position = Vector3.new(0, 1, 0)
    trail.Attachment1.Position = Vector3.new(0, -1, 0)

    trail.WidthScale = NumberSequence.new(0.1)
    trail.Parent = rootPart
    trail.Enabled = true
end

local function removeTrail()
    if trail then
        trail.Enabled = false
        trail:Destroy()
        trail = nil
    end
    if rgbLoop then
        rgbLoop:Disconnect()
        rgbLoop = nil
    end
end

local function updateTrailColor(color)
    trailColor = color
    if trail then
        trail.Color = ColorSequence.new(color)
    end
end

Visual:AddToggle("Trail", {
    Text = "Trail",
    Default = false,
    Callback = function(value)
        if value then
            removeTrail()
            createTrail(trailColor)
        else
            removeTrail()
        end
    end
}):AddColorPicker("TrailColorPicker", {
    Default = trailColor,
    Title = "Trail Color",
    Transparency = 0,
    Callback = function(color)
        updateTrailColor(color)
    end
})

Visual:AddToggle("RGBTrail", {
    Text = "RGB Trail",
    Default = false,
    Callback = function(Value)
        if Value then
            removeTrail()
            createTrail(Color3.fromRGB(255,0,0))
            local hue = 0
            rgbLoop = RunService.RenderStepped:Connect(function(dt)
                if trail then
                    hue = (hue + dt*0.2) % 1
                    trail.Color = ColorSequence.new(Color3.fromHSV(hue,1,1))
                end
            end)
        else
            removeTrail()
        end
    end
})

local Main_Game = require(game.Players.LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game)
local toolOffsetEnabled = false
local offsetX, offsetY, offsetZ = 0, 0, 0
local offsetLoop

Visual:AddToggle("ToolOffsetToggle", {
    Text = "Custom Tool Offset",
    Default = false,
    Callback = function(Value)
        toolOffsetEnabled = Value
        if toolOffsetEnabled then
            offsetLoop = game:GetService("RunService").RenderStepped:Connect(function()
                Main_Game.tooloffset = Vector3.new(offsetX, offsetY, offsetZ)
            end)
        else
            if offsetLoop then
                offsetLoop:Disconnect()
                offsetLoop = nil
            end
        end
    end
})

Visual:AddSlider("ToolOffsetX", {
    Text = "Offset X",
    Default = offsetX,
    Min = -10,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        offsetX = Value
    end
})

Visual:AddSlider("ToolOffsetY", {
    Text = "Offset Y",
    Default = offsetY,
    Min = -10,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        offsetY = Value
    end
})

Visual:AddSlider("ToolOffsetZ", {
    Text = "Offset Z",
    Default = offsetZ,
    Min = -10,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        offsetZ = Value
    end
})

local Ambience = Tabs.Visual:AddLeftGroupbox("Ambience")

pcall(function()
local Lighting = game:GetService("Lighting")

local DefaultLighting = {
    GlobalShadows = Lighting.GlobalShadows,
    Brightness = Lighting.Brightness,
    ClockTime = Lighting.ClockTime,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    ExposureCompensation = Lighting.ExposureCompensation,
}

local FullBrightConfig = {
    GlobalShadows = false,
    Brightness = 1,
    ClockTime = 14,
    OutdoorAmbient = Color3.fromRGB(192, 192, 192),
    ExposureCompensation = 0.25,
}

local DefaultFog = {
    FogStart = Lighting.FogStart,
    FogEnd = Lighting.FogEnd
}

local NoFogConfig = {
    FogStart = 0,
    FogEnd = 1e10
}

local FullBrightConnection
local NoFogConnection

local function ApplyFullBright()
    for prop, value in pairs(FullBrightConfig) do
        Lighting[prop] = value
    end
end

local function RestoreLightingDefaults()
    for prop, value in pairs(DefaultLighting) do
        Lighting[prop] = value
    end
end

local function ApplyNoFog()
    for prop, value in pairs(NoFogConfig) do
        Lighting[prop] = value
    end
end

local function RestoreFogDefaults()
    for prop, value in pairs(DefaultFog) do
        Lighting[prop] = value
    end
end

Ambience:AddToggle("FullBright", {
    Text = "FullBright",
    Default = false,
    Callback = function(Value)
        if FullBrightConnection then
            FullBrightConnection:Disconnect()
            FullBrightConnection = nil
        end
        RestoreLightingDefaults()
        if Value then
            ApplyFullBright()
            FullBrightConnection = Lighting.Changed:Connect(function(prop)
                if FullBrightConfig[prop] ~= nil and Lighting[prop] ~= FullBrightConfig[prop] then
                    Lighting[prop] = FullBrightConfig[prop]
                end
            end)
        end
    end
})

Ambience:AddToggle("NoFog", {
    Text = "No Fog",
    Default = false,
    Callback = function(Value)
        if NoFogConnection then
            NoFogConnection:Disconnect()
            NoFogConnection = nil
        end
        RestoreFogDefaults()
        if Value then
            ApplyNoFog()
            NoFogConnection = Lighting.Changed:Connect(function(prop)
                if NoFogConfig[prop] ~= nil and Lighting[prop] ~= NoFogConfig[prop] then
                    Lighting[prop] = NoFogConfig[prop]
                end
            end)
        end
    end
})

local Screen = Tabs.Visual:AddRightGroupbox("Screen")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local VignetteLoop

Screen:AddToggle("DisableHideVignette", {
    Text = "Disable Hide Vignette",
    Default = false,
    Callback = function(Value)
        if Value then
            VignetteLoop = RunService.RenderStepped:Connect(function()
                local Vignette = LocalPlayer:FindFirstChild("PlayerGui")
                                and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
                                and LocalPlayer.PlayerGui.MainUI:FindFirstChild("MainFrame")
                                and LocalPlayer.PlayerGui.MainUI.MainFrame:FindFirstChild("HideVignette")
                if Vignette and Vignette.Visible ~= false then
                    Vignette.Visible = false
                end
            end)
        else
            if VignetteLoop then
                VignetteLoop:Disconnect()
                VignetteLoop = nil
            end
        end
    end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TransparencyValue = 0.5
local HidingSpots = {"Wardrobe", "Bed", "Toolshed", "Rooms_Locker", "Rooms_Locker_Fridge", "Locker_Large", "Backdoor_Wardrobe"}
local OriginalTransparency = {}
local AffectedModels = {}
local HideEnabled = false

local function CollectHidingSpots()
    AffectedModels = {}
    for _, model in ipairs(workspace:GetDescendants()) do
        if model:IsA("Model") and table.find(HidingSpots, model.Name) then
            table.insert(AffectedModels, model)
            for _, obj in ipairs(model:GetDescendants()) do
                if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation") or obj:IsA("Part")) and not OriginalTransparency[obj] then
                    if obj.Transparency == 0 then
                        OriginalTransparency[obj] = obj.Transparency
                    end
                end
            end
        end
    end
end

local function UpdateTransparency()
    if not HideEnabled then return end
    local hiding = LocalPlayer.Character:GetAttribute("Hiding")
    for _, model in ipairs(AffectedModels) do
        for _, obj in ipairs(model:GetDescendants()) do
            if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation") or obj:IsA("Part")) and OriginalTransparency[obj] then
                if hiding then
                    obj.Transparency = TransparencyValue
                    obj.CanCollide = false
                else
                    obj.Transparency = OriginalTransparency[obj]
                    obj.CanCollide = true
                end
            end
        end
    end
end

CollectHidingSpots()

workspace.DescendantAdded:Connect(function(model)
    if model:IsA("Model") and table.find(HidingSpots, model.Name) then
        table.insert(AffectedModels, model)
        for _, obj in ipairs(model:GetDescendants()) do
            if (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation") or obj:IsA("Part")) and not OriginalTransparency[obj] then
                if obj.Transparency == 0 then
                    OriginalTransparency[obj] = obj.Transparency
                end
            end
        end
        UpdateTransparency()
    end
end)

LocalPlayer.Character:GetAttributeChangedSignal("Hiding"):Connect(UpdateTransparency)

Screen:AddToggle("HideSpotTransparency", {
    Text = "Hide Spot Transparency",
    Default = false,
    Callback = function(Value)
        HideEnabled = Value
        if HideEnabled then
            UpdateTransparency()
        else
            for obj, original in pairs(OriginalTransparency) do
                if obj and obj.Parent then
                    obj.Transparency = original
                    if obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("UnionOperation") or obj:IsA("Part") then
                        obj.CanCollide = true
                    end
                end
            end
        end
    end
})

Screen:AddSlider("HideSpotTransparency", {
    Text = "Transparency",
    Default = TransparencyValue,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Callback = function(Value)
        TransparencyValue = Value
        if HideEnabled then
            UpdateTransparency()
        end
    end
})

Library:OnUnload(function()
	print("Unloaded!")
	Library.Unloaded = true
end)

local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu")

MenuGroup:AddToggle("KeybindMenuOpen", {
	Default = Library.KeybindFrame.Visible,
	Text = "Open Keybind Menu",
	Callback = function(value)
		Library.KeybindFrame.Visible = value
	end,
})
MenuGroup:AddToggle("ShowCustomCursor", {
	Text = "Custom Cursor",
	Default = true,
	Callback = function(Value)
		Library.ShowCustomCursor = Value
	end,
})
MenuGroup:AddDropdown('Notification Side', {
	Values = {'Left', 'Right'},
	Default = 1,
	Multi = false,
	Text = 'Notification Side',
	Callback = function(Value)
		Library.NotifySide = Value
	end
})
MenuGroup:AddDivider()
MenuGroup:AddLabel("Menu bind")
	:AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })
MenuGroup:AddButton("Unload", function()
	Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
ThemeManager:SetFolder("Protohax")
SaveManager:SetFolder("Protohax/Doors")
SaveManager:SetSubFolder("Doors/Hotel")
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])
SaveManager:LoadAutoloadConfig()
end)
